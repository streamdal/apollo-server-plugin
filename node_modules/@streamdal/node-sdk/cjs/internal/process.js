"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runStep = exports.resultCondition = exports.getStepStatus = exports.processPipelines = exports.processPipeline = exports.retryProcessPipelines = exports.MAX_PAYLOAD_SIZE = void 0;
const sp_pipeline_1 = require("@streamdal/protos/protos/sp_pipeline");
const sp_sdk_1 = require("@streamdal/protos/protos/sp_sdk");
const sp_wsm_1 = require("@streamdal/protos/protos/sp_wsm");
const audience_js_1 = require("./audience.js");
const httpRequest_js_1 = require("./httpRequest.js");
const metrics_js_1 = require("./metrics.js");
const notify_js_1 = require("./notify.js");
const pipeline_js_1 = require("./pipeline.js");
const register_js_1 = require("./register.js");
const schema_js_1 = require("./schema.js");
const tail_js_1 = require("./tail.js");
const wasm_js_1 = require("./wasm.js");
exports.MAX_PAYLOAD_SIZE = 1024 * 1024; // 1 megabyte
const MAX_PIPELINE_RETRIES = 10;
const PIPELINE_RETRY_INTERVAL = 1000;
const retryProcessPipelines = async ({ configs, audience, data, }) => {
    let retries = 1;
    try {
        if (register_js_1.internal.registered) {
            return (0, exports.processPipelines)({
                configs,
                audience,
                data,
            });
        }
        console.info(`not yet registered with the grpc server, retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds...`);
        return new Promise((resolve) => {
            const intervalId = setInterval(() => {
                retries++;
                if (retries >= MAX_PIPELINE_RETRIES) {
                    clearInterval(intervalId);
                    return;
                }
                if (register_js_1.internal.registered) {
                    console.debug(`retrying process pipeline...`);
                    clearInterval(intervalId);
                    return resolve((0, exports.processPipelines)({
                        configs,
                        audience,
                        data,
                    }));
                }
                console.debug(`retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds; ${retries} of ${MAX_PIPELINE_RETRIES} retries`);
            }, PIPELINE_RETRY_INTERVAL);
        });
    }
    catch (e) {
        console.error("Error running process pipeline", e);
    }
    const statusMessage = "Node SDK not registered with the server, skipping pipeline. Is the server running?";
    console.error(statusMessage);
    return Promise.resolve({
        data,
        status: sp_sdk_1.ExecStatus.ERROR,
        pipelineStatus: [],
        statusMessage,
        metadata: {},
    });
};
exports.retryProcessPipelines = retryProcessPipelines;
const processPipeline = async ({ originalData, audience, configs, pipeline, }) => {
    const pipelineStatus = {
        id: pipeline.id,
        name: pipeline.name,
        stepStatus: [],
        metadata: {},
    };
    let data = originalData;
    let lastStepResult = undefined;
    for (const step of pipeline.steps) {
        if (configs.dryRun) {
            console.debug(`Dry run set. Found pipeline: ${pipeline.name}, step: ${step.name}...not running.`);
            continue;
        }
        console.debug(`running pipeline: ${pipeline.name}, step: ${step.name}...`);
        const { data: newData, stepStatus, interStepResult, } = await (0, exports.runStep)({
            originalData,
            audience,
            configs,
            step,
            pipeline,
            lastStepResult,
        });
        data = newData;
        pipelineStatus.stepStatus = [...pipelineStatus.stepStatus, stepStatus];
        lastStepResult = interStepResult;
        if (Object.keys(stepStatus.metadata).length) {
            pipelineStatus.metadata = {
                ...pipelineStatus.metadata,
                ...stepStatus.metadata,
            };
        }
        if ([sp_pipeline_1.AbortCondition.ABORT_CURRENT, sp_pipeline_1.AbortCondition.ABORT_ALL].includes(stepStatus.abortCondition)) {
            break;
        }
    }
    return { data, pipelineStatus };
};
exports.processPipeline = processPipeline;
const processPipelines = async ({ configs, audience, data, }) => {
    await (0, pipeline_js_1.initPipelines)(configs);
    await (0, audience_js_1.addAudience)({ configs: configs, audience });
    const key = (0, register_js_1.audienceKey)(audience);
    const pipelines = register_js_1.internal.pipelines.get(key);
    void (0, metrics_js_1.audienceMetrics)(audience, data.length);
    if (!pipelines) {
        const statusMessage = "No active pipelines found for this audience, returning data";
        console.debug(statusMessage);
        (0, tail_js_1.sendTail)({
            configs,
            audience,
            originalData: data,
        });
        return {
            data,
            status: sp_sdk_1.ExecStatus.TRUE,
            statusMessage,
            pipelineStatus: [],
            metadata: {},
        };
    }
    const response = {
        data,
        pipelineStatus: [],
        status: sp_sdk_1.ExecStatus.TRUE,
        statusMessage: "",
        metadata: {},
    };
    for (const pipeline of pipelines.values()) {
        const { data, pipelineStatus } = await (0, exports.processPipeline)({
            originalData: response.data,
            audience,
            configs,
            pipeline,
        });
        response.data = data;
        response.pipelineStatus = [...response.pipelineStatus, pipelineStatus];
        if (Object.keys(pipelineStatus.metadata).length) {
            response.metadata = { ...response.metadata, ...pipelineStatus.metadata };
        }
        const lastAbort = pipelineStatus.stepStatus.at(-1)?.abortCondition;
        if (lastAbort && [sp_pipeline_1.AbortCondition.ABORT_ALL].includes(lastAbort)) {
            break;
        }
    }
    (0, tail_js_1.sendTail)({
        configs,
        audience,
        originalData: data,
        newData: response.data,
    });
    const finalStatus = response.pipelineStatus.at(-1)?.stepStatus.at(-1);
    return Promise.resolve({
        ...response,
        ...(finalStatus && {
            status: finalStatus.status,
            statusMessage: finalStatus.statusMessage,
        }),
    });
};
exports.processPipelines = processPipelines;
const getStepStatus = (exitCode) => (exitCode === sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_TRUE
    ? sp_sdk_1.ExecStatus.TRUE
    : exitCode === sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_FALSE
        ? sp_sdk_1.ExecStatus.FALSE
        : exitCode === sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_ERROR
            ? sp_sdk_1.ExecStatus.ERROR
            : sp_sdk_1.ExecStatus.UNSET);
exports.getStepStatus = getStepStatus;
const resultCondition = ({ configs, audience, step, pipeline, stepStatus, payload, }) => {
    const condition = stepStatus.status === sp_sdk_1.ExecStatus.TRUE
        ? step.onTrue
        : stepStatus.status === sp_sdk_1.ExecStatus.FALSE
            ? step.onFalse
            : step.onError;
    condition?.notification?.notificationConfigIds.length &&
        void (0, notify_js_1.notifyStep)({
            configs,
            audience,
            step,
            stepStatus,
            pipelineId: pipeline.id,
            payload,
        });
    if (condition?.metadata && Object.keys(condition.metadata).length) {
        stepStatus.metadata = { ...stepStatus.metadata, ...condition.metadata };
    }
    stepStatus.abortCondition = condition?.abort
        ? condition.abort
        : sp_pipeline_1.AbortCondition.UNSET;
};
exports.resultCondition = resultCondition;
const runStep = async ({ originalData, audience, configs, step, pipeline, lastStepResult, }) => {
    const stepStatus = {
        name: step.name,
        status: sp_sdk_1.ExecStatus.TRUE,
        abortCondition: sp_pipeline_1.AbortCondition.UNSET,
        metadata: {},
    };
    const payloadSize = originalData.length;
    let data = originalData;
    let stepResult;
    try {
        const { outputPayload, outputStep, exitCode, exitMsg, interStepResult } = step.step.oneofKind === "httpRequest"
            ? await (0, httpRequest_js_1.httpRequest)({ step })
            : (0, wasm_js_1.runWasm)({
                step,
                originalData,
                interStepResult: lastStepResult,
            });
        //
        // output gets passed back as data for the next function
        stepStatus.status = (0, exports.getStepStatus)(exitCode);
        if (stepStatus.status !== sp_sdk_1.ExecStatus.ERROR && outputPayload) {
            data = outputPayload;
        }
        stepStatus.statusMessage = exitMsg;
        stepResult = interStepResult;
        stepStatus.status !== sp_sdk_1.ExecStatus.ERROR &&
            step.name.includes("Infer Schema") &&
            void (0, schema_js_1.sendSchema)({ configs, audience, schema: outputStep });
    }
    catch (error) {
        console.error(`error running pipeline step - ${step.name}`, error);
        stepStatus.status = sp_sdk_1.ExecStatus.ERROR;
        stepStatus.statusMessage = error.toString();
    }
    (0, exports.resultCondition)({
        configs,
        audience,
        step,
        pipeline,
        stepStatus,
        payload: data,
    });
    void (0, metrics_js_1.stepMetrics)({ audience, stepStatus, pipeline, payloadSize });
    return { data, interStepResult: stepResult, stepStatus };
};
exports.runStep = runStep;
//# sourceMappingURL=process.js.map