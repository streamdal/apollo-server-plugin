"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendMetrics = exports.audienceMetrics = exports.stepMetrics = exports.getStepLabels = exports.lock = exports.metrics = exports.METRIC_INTERVAL = void 0;
const sp_common_1 = require("@streamdal/protos/protos/sp_common");
const sp_sdk_1 = require("@streamdal/protos/protos/sp_sdk");
const rwlock_1 = __importDefault(require("rwlock"));
exports.METRIC_INTERVAL = 1000;
exports.metrics = new Map();
exports.lock = new rwlock_1.default();
const getStepLabels = (audience, pipeline) => ({
    service: audience.serviceName,
    component: audience.componentName,
    operation: audience.operationName,
    pipeline_id: pipeline.id,
    pipeline_name: pipeline.name,
});
exports.getStepLabels = getStepLabels;
const stepMetrics = async ({ audience, stepStatus, pipeline, payloadSize, }) => {
    exports.lock.writeLock((release) => {
        const opName = audience.operationType === sp_common_1.OperationType.CONSUMER ? "consume" : "produce";
        const labels = (0, exports.getStepLabels)(audience, pipeline);
        const stepErrorKey = `counter_${opName}_errors`;
        const stepProcessedKey = `counter_${opName}_processed`;
        const stepBytesKey = `counter_${opName}_bytes`;
        stepStatus.status === sp_sdk_1.ExecStatus.ERROR &&
            exports.metrics.set(stepErrorKey, {
                name: stepErrorKey,
                value: (exports.metrics.get(stepErrorKey)?.value ?? 0) + 1,
                labels,
                audience,
            });
        exports.metrics.set(stepProcessedKey, {
            name: stepProcessedKey,
            value: (exports.metrics.get(stepProcessedKey)?.value ?? 0) + 1,
            labels,
            audience,
        });
        exports.metrics.set(stepBytesKey, {
            name: stepBytesKey,
            value: (exports.metrics.get(stepBytesKey)?.value ?? 0) + payloadSize,
            labels,
            audience,
        });
        release();
    });
};
exports.stepMetrics = stepMetrics;
const audienceMetrics = async (audience, payloadSize
// eslint-disable-next-line @typescript-eslint/require-await
) => {
    exports.lock.writeLock((release) => {
        const opName = audience.operationType === sp_common_1.OperationType.CONSUMER ? "consume" : "produce";
        const bytesProcessedKey = `counter_${opName}_bytes_rate`;
        const processedKey = `counter_${opName}_processed_rate`;
        exports.metrics.set(bytesProcessedKey, {
            name: bytesProcessedKey,
            value: (exports.metrics.get(bytesProcessedKey)?.value ?? 0) + payloadSize,
            labels: {},
            audience,
        });
        exports.metrics.set(processedKey, {
            name: processedKey,
            value: (exports.metrics.get(processedKey)?.value ?? 0) + 1,
            labels: {},
            audience,
        });
        release();
    });
};
exports.audienceMetrics = audienceMetrics;
const sendMetrics = (configs) => exports.lock.writeLock((release) => {
    try {
        if (!exports.metrics.size) {
            console.debug(`### no metrics found, skipping`);
            release();
            return;
        }
        const metricsData = Array.from(exports.metrics.values()).map((m) => ({
            ...m,
            //
            // Make sure we always send data per second
            value: m.value / (exports.METRIC_INTERVAL / 1000),
        }));
        console.debug("sending metrics", metricsData);
        void configs.grpcClient.metrics({
            metrics: metricsData,
        }, { meta: { "auth-token": configs.streamdalToken } });
        exports.metrics.clear();
    }
    catch (e) {
        console.error("error sending metrics", e);
    }
    release();
});
exports.sendMetrics = sendMetrics;
//# sourceMappingURL=metrics.js.map