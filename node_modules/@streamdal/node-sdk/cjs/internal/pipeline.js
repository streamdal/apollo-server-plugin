"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tailPipeline = exports.setPipelines = exports.buildPipeline = exports.processResponse = exports.initPipelines = void 0;
const sp_common_1 = require("@streamdal/protos/protos/sp_common");
const kv_js_1 = require("./kv.js");
const register_js_1 = require("./register.js");
const tokenBucket_js_1 = require("./utils/tokenBucket.js");
const wasm_js_1 = require("./wasm.js");
const initPipelines = async (configs) => {
    try {
        if (register_js_1.internal.pipelineInitialized) {
            return;
        }
        console.debug("initializing pipelines");
        const { response } = await configs.grpcClient.getSetPipelinesCommandsByService({
            serviceName: configs.serviceName.toLowerCase(),
        }, { meta: { "auth-token": configs.streamdalToken } });
        for await (const [k, v] of Object.entries(response.wasmModules)) {
            await (0, wasm_js_1.instantiateWasm)(k, v.bytes);
        }
        for await (const command of response.setPipelineCommands) {
            await (0, exports.processResponse)(command);
        }
        register_js_1.internal.pipelineInitialized = true;
    }
    catch (e) {
        console.error("Error initializing pipelines", e);
    }
};
exports.initPipelines = initPipelines;
const processResponse = async (response) => {
    if (response.command.oneofKind === "kv") {
        (0, kv_js_1.kvCommand)(response.command.kv);
        return;
    }
    if (!response.audience) {
        response.command.oneofKind !== "keepAlive" &&
            console.debug("command response has no audience, ignoring");
        return;
    }
    switch (response.command.oneofKind) {
        case "setPipelines":
            await (0, exports.setPipelines)(response.audience, response.command.setPipelines.pipelines);
            break;
        case "tail":
            (0, exports.tailPipeline)(response.audience, response.command.tail);
            break;
    }
};
exports.processResponse = processResponse;
const buildPipeline = async (pipeline) => {
    return {
        ...pipeline,
        steps: await Promise.all(pipeline.steps.map(async (step) => {
            await (0, wasm_js_1.instantiateWasm)(step.WasmId, step.WasmBytes);
            return {
                ...step,
                WasmBytes: undefined,
            };
        })),
    };
};
exports.buildPipeline = buildPipeline;
const setPipelines = async (audience, pipelines) => {
    const key = (0, register_js_1.audienceKey)(audience);
    const mappedPipelines = await Promise.all(pipelines.map(async (p) => [p.id, await (0, exports.buildPipeline)(p)]));
    register_js_1.internal.pipelines.set(key, new Map(mappedPipelines));
};
exports.setPipelines = setPipelines;
const tailPipeline = (audience, { request }) => {
    console.debug("received a tail command for audience", audience);
    if (!request) {
        console.debug("no tail request details specified, skipping");
        return;
    }
    switch (request.type) {
        case sp_common_1.TailRequestType.START: {
            console.debug("received a START tail: adding entry to audiences for tail id", audience);
            // Create inner map if it doesn't exist
            if (!register_js_1.internal.audiences.has((0, register_js_1.audienceKey)(audience))) {
                register_js_1.internal.audiences.set((0, register_js_1.audienceKey)(audience), {
                    audience,
                    tails: new Map(),
                });
            }
            // Add entry (@JH, OK if overwritten?)
            request.id &&
                register_js_1.internal.audiences.get((0, register_js_1.audienceKey)(audience))?.tails.set(request.id, {
                    tailStatus: request.type === sp_common_1.TailRequestType.START,
                    tailRequestId: request.id,
                    sampleBucket: new tokenBucket_js_1.TokenBucket(request.sampleOptions?.sampleRate, request.sampleOptions?.sampleIntervalSeconds),
                });
            break;
        }
        case sp_common_1.TailRequestType.STOP: {
            console.debug("received a STOP tail: removing entry from audiences for tail id", request.id);
            request.id &&
                register_js_1.internal.audiences.get((0, register_js_1.audienceKey)(audience))?.tails.delete(request.id);
            break;
        }
        default:
            console.error("unknown tail request type ", request.type);
            break;
    }
};
exports.tailPipeline = tailPipeline;
//# sourceMappingURL=pipeline.js.map