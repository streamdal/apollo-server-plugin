"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWasm = exports.writeResponse = exports.instantiateWasm = void 0;
const sp_wsm_1 = require("@streamdal/protos/protos/sp_wsm");
// eslint-disable-next-line import/no-unresolved
const wasi_1 = require("wasi");
const kv_js_1 = require("./kv.js");
const process_js_1 = require("./process.js");
const register_js_1 = require("./register.js");
const [nodeVersionMajor] = process.versions.node.split(".");
const wasi = new wasi_1.WASI({
    ...(Number(nodeVersionMajor) >= 20 ? { version: "preview1" } : {}),
    preopens: {
        "/sandbox": "./",
    },
});
//
// We bypass wasm for some things in node (async) but we still
// need to have a host function mapped so wasm instantiation
// doesn't blow up.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const hostFunctionNOOP = (_, __, ____) => BigInt(0);
const instantiateWasm = async (wasmId, wasmBytes) => {
    if (!wasmId || !wasmBytes || wasmBytes.length === 0) {
        console.debug("Wasm info missing, skipping instantiation, .");
        return;
    }
    if (register_js_1.internal.wasmModules.has(wasmId)) {
        console.debug("Wasm exists, skipping instantiation");
        return;
    }
    const wasm = await WebAssembly.compile(wasmBytes);
    const instantiated = await WebAssembly.instantiate(wasm, {
        wasi_snapshot_preview1: wasi.wasiImport,
        env: {
            kvExists: (pointer, length) => (0, kv_js_1.kvExists)(instantiated.exports, pointer, length),
            httpRequest: (pointer, length) => hostFunctionNOOP(instantiated.exports, pointer, length),
        },
    });
    register_js_1.internal.wasmModules.set(wasmId, instantiated);
};
exports.instantiateWasm = instantiateWasm;
const readResponse = (pointer, buffer) => {
    //
    // Shift right by 32 bits to get the start value
    const start = Number(pointer >> BigInt(32));
    //
    // Bitwise AND operation with 0xFFFFFFFF to get the length
    const length = Number(pointer & BigInt(0xffffffff));
    return buffer.slice(start, start + length);
};
const writeResponse = (pointer, length) => {
    //
    // Left shift the pointer value by 32 bits
    const start = BigInt(pointer) << BigInt(32);
    //
    // Combine the shifted start and length using bitwise OR
    return start | BigInt(length);
};
exports.writeResponse = writeResponse;
const runWasm = ({ step, originalData, interStepResult, }) => {
    if (originalData.length > process_js_1.MAX_PAYLOAD_SIZE) {
        return {
            outputStep: null,
            outputPayload: new Uint8Array(),
            exitCode: sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_ERROR,
            exitMsg: "Payload exceeds maximum size",
            interStepResult: undefined,
        };
    }
    const request = sp_wsm_1.WASMRequest.create({
        step: {
            name: step.name,
            step: step.step,
            dynamic: step.dynamic,
        },
        inputPayload: originalData,
        interStepResult,
    });
    const { exports } = register_js_1.internal.wasmModules.get(step.WasmId);
    const { memory, alloc, [step.WasmFunction]: f } = exports;
    const requestBytes = sp_wsm_1.WASMRequest.toBinary(request);
    const ptr = alloc(requestBytes.length);
    const mem = new Uint8Array(memory.buffer, ptr, requestBytes.length);
    mem.set(requestBytes);
    const returnPtr = BigInt(f(ptr, requestBytes.length));
    const response = readResponse(returnPtr, new Uint8Array(memory.buffer));
    return sp_wsm_1.WASMResponse.fromBinary(response);
};
exports.runWasm = runWasm;
//# sourceMappingURL=wasm.js.map