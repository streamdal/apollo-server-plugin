"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.retryRegister = exports.processRegisterResponses = exports.clientInfo = exports.version = exports.audienceKey = exports.internal = void 0;
const node_fs_1 = require("node:fs");
const sp_info_1 = require("@streamdal/protos/protos/sp_info");
const pipeline_js_1 = require("./pipeline.js");
const REGISTRATION_RETRY_INTERVAL = 5000;
exports.internal = {
    // we track registered status so downstream process pipeline
    // requests can be retried
    registered: false,
    pipelineInitialized: false,
    pipelines: new Map(),
    kv: new Map(),
    audiences: new Map(),
    wasmModules: new Map(),
    schemas: new Map(),
};
const audienceKey = (audience) => JSON.stringify(audience).toLowerCase();
exports.audienceKey = audienceKey;
const version = () => {
    try {
        const pkg = JSON.parse((0, node_fs_1.readFileSync)("./node_modules/@streamdal/node-sdk/package.json").toString());
        return (pkg?.version ? pkg.version : "unknown");
    }
    catch (e) {
        console.error("Error getting package version");
    }
    return "unknown";
};
exports.version = version;
exports.clientInfo = {
    clientType: sp_info_1.ClientType.SDK,
    libraryName: "node-sdk",
    libraryVersion: (0, exports.version)(),
    language: "Typescript",
    arch: process.arch,
    os: process.platform,
};
const processRegisterResponses = async (call, configs) => {
    try {
        for await (const response of call.responses) {
            if (response.command.oneofKind !== "keepAlive") {
                await (0, pipeline_js_1.processResponse)(response);
            }
        }
    }
    catch (error) {
        exports.internal.registered = false;
        console.error("error processing register responses, retrying register", error);
        (0, exports.retryRegister)(configs);
    }
};
exports.processRegisterResponses = processRegisterResponses;
const retryRegister = (configs) => setTimeout(() => {
    console.info(`retrying registering with grpc server in ${REGISTRATION_RETRY_INTERVAL / 1000} seconds...`);
    void (0, exports.register)(configs);
}, REGISTRATION_RETRY_INTERVAL);
exports.retryRegister = retryRegister;
const register = async (configs) => {
    try {
        console.info(`### running node-sdk version: ${exports.clientInfo.libraryVersion}`);
        console.info(`### registering with grpc server...`);
        const call = configs.grpcClient.register({
            sessionId: configs.sessionId,
            serviceName: configs.serviceName,
            dryRun: configs.dryRun,
            clientInfo: exports.clientInfo,
            audiences: Array.from(exports.internal.audiences.values()).map((a) => a.audience),
        }, {
            meta: { "auth-token": configs.streamdalToken },
        });
        await call.headers;
        console.info(`### registered with grpc server`);
        //
        // considering response headers without errors as registered;
        // don't block while we wait to process stream responses
        exports.internal.registered = true;
        void (0, exports.processRegisterResponses)(call, configs);
    }
    catch (error) {
        exports.internal.registered = false;
        console.error("error registering with grpc server", error);
        (0, exports.retryRegister)(configs);
    }
};
exports.register = register;
//# sourceMappingURL=register.js.map